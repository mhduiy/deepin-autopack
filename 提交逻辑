1. 一个一个的任务列表，可以独立运行，可以后台运行，可以自动监控

## 任务提交前

1. 用户从提交监控页面可以开始打包，应该保存用户所有的打包配置的相关信息，用于后续的重试
2. 用户可以选择不同的打包模式，之后可能还会增加其他的打包选项，这些都要存储到一个单独的任务中
3. 一个任务应该可以获取到当前打包的一些基础信息

## 任务执行中

流程：
1. 检查仓库状态：本地仓库是否存在，必要的二进制工具是否安装（比如dch）
2. 拉取最新提交并合并到当前分支：虽然之前肯定已经拉取过了，但是这里还是要拉取一次
3. 提交changelog：生成changelog文件（应该可以通过dch自动生成，可以指定版本号，维护者），这里一定要注意分支管理，避免冲突，也要考虑到重试的场景，github 还需要添加自己的分支，上游的分支，因为要提交PR，pr的提交可以通过gh命令
4. 提交commit，生成commit msg
5. 推送commit，提交到gerrit或者github（填了github就一定是github维护的仓库，gerrit只是辅助打包的，这里推动就推动github自己的仓库）
6. 提交PR（仅github）
7. 监控PR状态，每隔几十秒监控一次状态，或者可以用户手点击刷新按钮刷新状态，这里可能涉及到访问限制，所以要注意，gerrit提交也需要报告状态（没有PR），当成功合并后进入下一步【如果仅提交changelog到这里就结束了】
8. 监控提交同步状态：监控github的提交是否同步到gerrit（这里只针对github的项目， 内部有自动的流程可以将提交自动同步到gerrit，因为crp打包只支持gerrit，但这需要时间， 同步的commit hash是一致的，gerrit的项目没有这一步，可以跳过）
9. CRP打包，读取用户提交任务的信息，通过CRPAPI直接提交打包请求
10. 监控打包状态，CRP返回打包成功，整个流程就走完了

## 失败情况

1. 告知用户必要日志，失败原因，失败步骤点
2. 可以完全重试，可以只重试某一步
3. 部分操作可能超时，有没有一种可以界面友好的手动检查状态的按钮

## 你的计划

### 一、数据库设计

#### 1. BuildTask 模型（打包任务表）
```python
class BuildTask(db.Model):
    """打包任务模型"""
    __tablename__ = 'build_tasks'
    
    # 基础信息
    id = db.Column(db.Integer, primary_key=True)
    project_id = db.Column(db.Integer, db.ForeignKey('projects.id'), nullable=False)
    project_name = db.Column(db.String(255), nullable=False)  # 冗余字段，方便查询
    
    # 打包配置
    package_mode = db.Column(db.String(20), nullable=False)  # 'normal', 'changelog_only', 'crp_only'
    version = db.Column(db.String(50), nullable=False)  # 版本号
    architectures = db.Column(db.JSON)  # 架构列表 ['amd64', 'arm64', 'loongarch64', 'riscv64']
    crp_topic_id = db.Column(db.String(50))  # CRP主题ID（可选）
    start_commit_hash = db.Column(db.String(40), nullable=False)  # 起始commit
    
    # 任务状态
    status = db.Column(db.String(20), default='pending')  
    # pending/running/paused/success/failed/cancelled
    current_step = db.Column(db.Integer, default=0)  # 当前执行到第几步（从0开始）
    error_message = db.Column(db.Text)  # 错误信息
    
    # GitHub相关
    github_branch = db.Column(db.String(100))  # 创建的打包分支名
    github_pr_number = db.Column(db.Integer)  # PR编号
    github_pr_url = db.Column(db.String(500))  # PR链接
    github_pr_status = db.Column(db.String(20))  # open/merged/closed
    
    # Gerrit同步状态（仅GitHub项目）
    gerrit_synced = db.Column(db.Boolean, default=False)  # 是否已同步到Gerrit
    gerrit_commit_hash = db.Column(db.String(40))  # Gerrit上的commit hash
    
    # CRP打包状态
    crp_build_id = db.Column(db.String(100))  # CRP打包任务ID
    crp_build_status = db.Column(db.String(20))  # pending/building/success/failed
    crp_build_url = db.Column(db.String(500))  # CRP打包任务链接
    
    # 时间戳
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    started_at = db.Column(db.DateTime)  # 任务开始时间
    completed_at = db.Column(db.DateTime)  # 任务完成时间
    
    # 关联关系
    steps = db.relationship('BuildTaskStep', backref='task', cascade='all, delete-orphan')
```

#### 2. BuildTaskStep 模型（任务步骤表）
```python
class BuildTaskStep(db.Model):
    """打包任务步骤模型"""
    __tablename__ = 'build_task_steps'
    
    id = db.Column(db.Integer, primary_key=True)
    task_id = db.Column(db.Integer, db.ForeignKey('build_tasks.id'), nullable=False)
    step_order = db.Column(db.Integer, nullable=False)  # 步骤顺序
    step_name = db.Column(db.String(100), nullable=False)  # 步骤名称
    status = db.Column(db.String(20), default='pending')  # pending/running/completed/failed/skipped
    log_message = db.Column(db.Text)  # 日志信息
    error_message = db.Column(db.Text)  # 错误信息
    started_at = db.Column(db.DateTime)
    completed_at = db.Column(db.DateTime)
    retry_count = db.Column(db.Integer, default=0)  # 重试次数
```

### 二、步骤定义与流程

#### 标准步骤列表（根据打包模式动态生成）
```python
# 正常打包模式步骤
NORMAL_MODE_STEPS = [
    {'order': 1, 'name': '检查环境', 'description': '检查仓库状态和工具'},
    {'order': 2, 'name': '拉取最新代码', 'description': '更新本地仓库'},
    {'order': 3, 'name': '生成Changelog', 'description': '使用dch生成changelog'},
    {'order': 4, 'name': '提交Commit', 'description': '提交changelog变更'},
    {'order': 5, 'name': '推送到远程', 'description': '推送到GitHub/Gerrit'},
    {'order': 6, 'name': '创建PR', 'description': '创建Pull Request（GitHub）'},
    {'order': 7, 'name': '监控PR状态', 'description': '等待PR合并'},
    {'order': 8, 'name': '等待同步', 'description': '等待GitHub同步到Gerrit（GitHub项目）'},
    {'order': 9, 'name': 'CRP打包', 'description': '提交CRP打包任务'},
    {'order': 10, 'name': '监控打包', 'description': '监控CRP打包状态'},
]

# 仅Changelog模式（步骤1-7）
CHANGELOG_ONLY_STEPS = NORMAL_MODE_STEPS[:7]

# 仅CRP打包模式（跳过changelog，直接从现有commit打包）
CRP_ONLY_STEPS = [
    {'order': 1, 'name': '检查环境', 'description': '检查配置和权限'},
    {'order': 2, 'name': 'CRP打包', 'description': '提交CRP打包任务'},
    {'order': 3, 'name': '监控打包', 'description': '监控CRP打包状态'},
]
```

### 三、核心服务层设计

#### BuildTaskService - 任务管理服务
```python
class BuildTaskService:
    """打包任务管理服务"""
    
    @staticmethod
    def create_task(project_id, package_config):
        """创建打包任务
        
        Args:
            project_id: 项目ID
            package_config: {
                'mode': 'normal'|'changelog_only'|'crp_only',
                'version': '6.0.52',
                'architectures': ['amd64', 'arm64'],
                'crp_topic_id': 'xxx',
                'start_commit_hash': 'abc123'
            }
        """
        pass
    
    @staticmethod
    def start_task(task_id):
        """启动任务（后台异步执行）"""
        pass
    
    @staticmethod
    def pause_task(task_id):
        """暂停任务"""
        pass
    
    @staticmethod
    def resume_task(task_id):
        """恢复任务"""
        pass
    
    @staticmethod
    def retry_task(task_id, from_step=None):
        """重试任务
        
        Args:
            task_id: 任务ID
            from_step: 从第几步开始重试（None=全部重试，0=从头，1+=从指定步骤）
        """
        pass
    
    @staticmethod
    def cancel_task(task_id):
        """取消任务"""
        pass
    
    @staticmethod
    def get_task_status(task_id):
        """获取任务状态"""
        pass
```

#### BuildExecutor - 任务执行器
```python
class BuildExecutor:
    """打包任务执行器（核心逻辑）"""
    
    def __init__(self, task_id):
        self.task = BuildTask.query.get(task_id)
        self.project = Project.query.get(self.task.project_id)
        self.config = GlobalConfig.get_config()
        self.stopped = False  # 停止标志
        
    def execute(self):
        """执行任务主流程"""
        try:
            self.task.status = 'running'
            self.task.started_at = datetime.utcnow()
            db.session.commit()
            
            # 根据模式选择步骤
            steps = self._get_steps_for_mode()
            
            for step in steps:
                if self.stopped:
                    break
                    
                self._execute_step(step)
                
            self.task.status = 'success'
            self.task.completed_at = datetime.utcnow()
            
        except Exception as e:
            self.task.status = 'failed'
            self.task.error_message = str(e)
            logger.exception(f"任务执行失败: {e}")
        finally:
            db.session.commit()
    
    def _execute_step(self, step_order):
        """执行单个步骤"""
        step = self.task.steps[step_order]
        step.status = 'running'
        step.started_at = datetime.utcnow()
        db.session.commit()
        
        try:
            # 根据步骤名称调用对应的处理方法
            handler = getattr(self, f'_step_{step.step_name.replace(" ", "_").lower()}')
            handler(step)
            
            step.status = 'completed'
            step.completed_at = datetime.utcnow()
            self.task.current_step = step_order + 1
            
        except Exception as e:
            step.status = 'failed'
            step.error_message = str(e)
            raise
        finally:
            db.session.commit()
    
    # 步骤实现方法
    def _step_检查环境(self, step):
        """步骤1: 检查环境"""
        # 检查本地仓库是否存在
        if not os.path.exists(self.project.local_repo_path):
            raise Exception(f"本地仓库不存在: {self.project.local_repo_path}")
        
        # 检查dch工具
        if not shutil.which('dch'):
            raise Exception("未安装dch工具，请安装devscripts")
        
        # 检查gh命令（GitHub项目）
        if self.project.github_url and not shutil.which('gh'):
            raise Exception("未安装gh工具，请安装GitHub CLI")
        
        step.log_message = "环境检查通过"
    
    def _step_拉取最新代码(self, step):
        """步骤2: 拉取最新代码"""
        git_service = GitService(self.project.local_repo_path)
        git_service.fetch()
        git_service.checkout(self.project.gerrit_branch or self.project.github_branch)
        git_service.pull()
        step.log_message = "代码拉取成功"
    
    def _step_生成changelog(self, step):
        """步骤3: 生成Changelog"""
        changelog_service = ChangelogService(
            repo_path=self.project.local_repo_path,
            maintainer_name=self.config.maintainer_name,
            maintainer_email=self.config.maintainer_email
        )
        
        # 创建打包分支（GitHub项目需要）
        if self.project.github_url:
            branch_name = f"autopack/{self.task.version}"
            git_service = GitService(self.project.local_repo_path)
            git_service.create_branch(branch_name)
            self.task.github_branch = branch_name
            db.session.commit()
        
        # 生成changelog
        changelog_service.generate(
            version=self.task.version,
            message=f"Release {self.task.version}"
        )
        
        step.log_message = f"Changelog已生成: {self.task.version}"
    
    def _step_提交commit(self, step):
        """步骤4: 提交Commit"""
        git_service = GitService(self.project.local_repo_path)
        commit_msg = f"chore: Release {self.task.version}"
        commit_hash = git_service.commit(commit_msg)
        step.log_message = f"Commit提交成功: {commit_hash[:8]}"
    
    def _step_推送到远程(self, step):
        """步骤5: 推送到远程"""
        git_service = GitService(self.project.local_repo_path)
        
        if self.project.github_url:
            # GitHub项目推送自己的分支
            git_service.push(self.task.github_branch)
        else:
            # Gerrit项目直接推送
            git_service.push_gerrit(self.project.gerrit_branch)
        
        step.log_message = "推送成功"
    
    def _step_创建pr(self, step):
        """步骤6: 创建PR（仅GitHub）"""
        if not self.project.github_url:
            step.status = 'skipped'
            return
        
        github_service = GitHubService(self.config.github_token)
        pr = github_service.create_pr(
            repo_url=self.project.github_url,
            head=self.task.github_branch,
            base=self.project.github_branch,
            title=f"Release {self.task.version}",
            body=f"Automated release for version {self.task.version}"
        )
        
        self.task.github_pr_number = pr['number']
        self.task.github_pr_url = pr['html_url']
        self.task.github_pr_status = 'open'
        db.session.commit()
        
        step.log_message = f"PR创建成功: {pr['html_url']}"
    
    def _step_监控pr状态(self, step):
        """步骤7: 监控PR状态"""
        if not self.project.github_url:
            step.status = 'skipped'
            return
        
        # 轮询检查PR状态（最多等待30分钟，每30秒检查一次）
        github_service = GitHubService(self.config.github_token)
        timeout = 1800  # 30分钟
        interval = 30  # 30秒
        elapsed = 0
        
        while elapsed < timeout:
            if self.stopped:
                raise Exception("任务已暂停")
            
            pr_status = github_service.get_pr_status(
                self.project.github_url,
                self.task.github_pr_number
            )
            
            self.task.github_pr_status = pr_status['state']
            db.session.commit()
            
            if pr_status['merged']:
                step.log_message = "PR已合并"
                return
            elif pr_status['state'] == 'closed':
                raise Exception("PR被关闭，未合并")
            
            time.sleep(interval)
            elapsed += interval
        
        # 超时未合并，暂停任务等待手动检查
        self.task.status = 'paused'
        db.session.commit()
        raise Exception("PR合并超时，任务已暂停，请手动检查后继续")
    
    def _step_等待同步(self, step):
        """步骤8: 等待GitHub同步到Gerrit"""
        if not self.project.github_url:
            step.status = 'skipped'
            return
        
        # 获取GitHub最新的commit hash
        git_service = GitService(self.project.local_repo_path)
        git_service.fetch()
        github_commit = git_service.get_commit_hash(self.project.github_branch)
        
        # 轮询检查Gerrit是否有相同的commit
        gerrit_service = GerritService(
            self.config.gerrit_url,
            self.config.ldap_username,
            self.config.ldap_password
        )
        
        timeout = 600  # 10分钟
        interval = 30
        elapsed = 0
        
        while elapsed < timeout:
            if self.stopped:
                raise Exception("任务已暂停")
            
            # 检查Gerrit分支最新commit
            gerrit_commits = gerrit_service.get_commits(
                self.project.gerrit_url,
                self.project.gerrit_branch,
                limit=10
            )
            
            for commit in gerrit_commits:
                if commit['commit'] == github_commit:
                    self.task.gerrit_synced = True
                    self.task.gerrit_commit_hash = github_commit
                    db.session.commit()
                    step.log_message = f"同步完成: {github_commit[:8]}"
                    return
            
            time.sleep(interval)
            elapsed += interval
        
        # 超时未同步
        self.task.status = 'paused'
        db.session.commit()
        raise Exception("同步超时，任务已暂停，请手动检查后继续")
    
    def _step_crp打包(self, step):
        """步骤9: CRP打包"""
        crp_service = CRPService(
            self.config.crp_token,
            self.config.crp_branch_id
        )
        
        # 确定commit hash
        if self.task.package_mode == 'crp_only':
            # 仅CRP模式，使用指定的commit
            commit_hash = self.task.start_commit_hash
        elif self.project.github_url:
            # GitHub项目，使用同步后的gerrit commit
            commit_hash = self.task.gerrit_commit_hash
        else:
            # Gerrit项目，使用最新commit
            git_service = GitService(self.project.local_repo_path)
            commit_hash = git_service.get_commit_hash()
        
        # 提交打包任务
        build_result = crp_service.submit_build(
            project_name=self.project.name,
            commit_hash=commit_hash,
            architectures=self.task.architectures,
            topic_id=self.task.crp_topic_id
        )
        
        self.task.crp_build_id = build_result['build_id']
        self.task.crp_build_url = build_result['url']
        self.task.crp_build_status = 'building'
        db.session.commit()
        
        step.log_message = f"CRP打包任务已提交: {build_result['build_id']}"
    
    def _step_监控打包(self, step):
        """步骤10: 监控打包状态"""
        crp_service = CRPService(
            self.config.crp_token,
            self.config.crp_branch_id
        )
        
        timeout = 3600  # 1小时
        interval = 60  # 1分钟
        elapsed = 0
        
        while elapsed < timeout:
            if self.stopped:
                raise Exception("任务已暂停")
            
            status = crp_service.get_build_status(self.task.crp_build_id)
            self.task.crp_build_status = status['status']
            db.session.commit()
            
            if status['status'] == 'success':
                step.log_message = "打包成功"
                return
            elif status['status'] == 'failed':
                raise Exception(f"打包失败: {status.get('error', '未知错误')}")
            
            time.sleep(interval)
            elapsed += interval
        
        # 超时
        self.task.status = 'paused'
        db.session.commit()
        raise Exception("打包超时，任务已暂停，请手动检查后继续")
```

### 四、异步任务执行方案

#### 方案选择：使用 Python threading + 队列
```python
# 在 app/services/build_task_service.py

import threading
import queue
from concurrent.futures import ThreadPoolExecutor

class TaskQueue:
    """任务队列管理器（单例）"""
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.queue = queue.Queue()
            cls._instance.executor = ThreadPoolExecutor(max_workers=3)  # 最多3个并发任务
            cls._instance.running_tasks = {}  # task_id -> Future
        return cls._instance
    
    def submit_task(self, task_id):
        """提交任务到队列"""
        future = self.executor.submit(self._run_task, task_id)
        self.running_tasks[task_id] = future
        return future
    
    def _run_task(self, task_id):
        """执行任务"""
        try:
            executor = BuildExecutor(task_id)
            executor.execute()
        finally:
            if task_id in self.running_tasks:
                del self.running_tasks[task_id]
    
    def stop_task(self, task_id):
        """停止任务"""
        if task_id in self.running_tasks:
            # 设置停止标志（需要executor支持）
            pass
    
    def is_running(self, task_id):
        """检查任务是否在运行"""
        return task_id in self.running_tasks
```

### 五、API接口设计

#### 1. 创建任务
```
POST /api/tasks/create
Body: {
    "project_id": 1,
    "mode": "normal",
    "version": "6.0.52",
    "architectures": ["amd64", "arm64"],
    "crp_topic_id": "xxx",
    "start_commit_hash": "abc123"
}
Response: {
    "success": true,
    "task_id": 123
}
```

#### 2. 启动任务
```
POST /api/tasks/{task_id}/start
Response: {"success": true}
```

#### 3. 获取任务状态
```
GET /api/tasks/{task_id}
Response: {
    "success": true,
    "data": {
        "id": 123,
        "status": "running",
        "current_step": 3,
        "steps": [...],
        "progress": 30,
        ...
    }
}
```

#### 4. 暂停/继续/取消任务
```
POST /api/tasks/{task_id}/pause
POST /api/tasks/{task_id}/resume
POST /api/tasks/{task_id}/cancel
```

#### 5. 重试任务
```
POST /api/tasks/{task_id}/retry
Body: {
    "from_step": 3  # 可选，从第几步开始
}
```

#### 6. 刷新步骤状态（手动检查）
```
POST /api/tasks/{task_id}/refresh-step
Body: {
    "step_order": 7  # 刷新第7步的状态
}
```

### 六、前端集成

#### Monitor页面 - 提交打包按钮
```javascript
async function submitPackageTask() {
    const config = {
        project_id: currentProjectId,
        mode: selectedMode,
        version: document.getElementById('versionInput').value,
        architectures: getSelectedArchitectures(),
        crp_topic_id: document.getElementById('crpTopicSelect').value,
        start_commit_hash: currentCommitHash
    };
    
    const response = await fetch('/api/tasks/create', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(config)
    });
    
    const result = await response.json();
    if (result.success) {
        // 立即启动任务
        await fetch(`/api/tasks/${result.task_id}/start`, {method: 'POST'});
        
        // 跳转到打包任务页面
        window.location.href = `/tasks?highlight=${result.task_id}`;
    }
}
```

#### Build页面 - 任务列表实时刷新
```javascript
// 每5秒刷新一次任务列表
setInterval(async () => {
    const response = await fetch('/api/tasks');
    const result = await response.json();
    updateTaskCards(result.data);
}, 5000);
```

### 七、错误处理与重试机制

#### 1. 自动重试策略
- 网络错误：自动重试3次，间隔5秒
- 临时失败（API限流）：自动重试，指数退避
- 致命错误：停止任务，等待人工介入

#### 2. 超时处理
- PR合并超时：暂停任务，提示"请手动检查PR状态后点击继续"
- 同步超时：暂停任务，提示"请检查同步状态后继续"
- 打包超时：暂停任务，提供"刷新状态"按钮

#### 3. 手动干预点
- 提供"刷新步骤状态"按钮，允许用户手动检查某个步骤是否完成
- 提供"跳过当前步骤"选项（需确认，用于异常情况）
- 提供"从指定步骤重试"功能

### 八、实施步骤

1. **Phase 1: 数据库与模型**（1天）
   - 创建BuildTask和BuildTaskStep模型
   - 编写数据库迁移脚本
   - 测试模型CRUD操作

2. **Phase 2: 核心执行器**（3天）
   - 实现BuildExecutor类
   - 实现所有步骤处理方法
   - 单元测试每个步骤

3. **Phase 3: 任务队列**（1天）
   - 实现TaskQueue管理器
   - 实现异步任务提交和管理
   - 测试并发执行

4. **Phase 4: API接口**（1天）
   - 实现所有REST API
   - 测试接口功能

5. **Phase 5: 前端集成**（2天）
   - Monitor页面集成提交功能
   - Build页面实现实时刷新
   - 添加控制按钮（暂停/继续/重试）

6. **Phase 6: 错误处理优化**（1天）
   - 完善错误处理逻辑
   - 实现重试机制
   - 添加超时处理

7. **Phase 7: 测试与优化**（2天）
   - 端到端测试完整流程
   - 压力测试并发任务
   - 优化性能和用户体验

### 九、技术要点

1. **线程安全**：使用Flask-SQLAlchemy的会话管理，每个线程独立session
2. **日志记录**：所有步骤详细记录到数据库，方便排查问题
3. **状态持久化**：任务状态实时保存，重启后可恢复
4. **优雅停止**：支持暂停和取消，不会造成数据不一致
5. **幂等性**：重试操作保证幂等，避免重复执行
6. **资源隔离**：每个任务使用独立的工作目录（Git worktree）

### 十、后续扩展

1. **Webhook集成**：接收GitHub/Gerrit webhook，自动更新任务状态
2. **通知系统**：任务完成/失败时发送邮件或IM通知
3. **批量打包**：支持一次性为多个项目创建打包任务
4. **定时任务**：定期检查新提交并自动打包
5. **统计报表**：打包成功率、耗时分析等

---

## 需要用户提供的信息清单

### 一、CRP 平台 API

#### 1. 提交打包任务接口
```
接口用途：向CRP平台提交一个新的打包任务
请求方式：POST / GET / PUT / DELETE （请标注）
接口地址：

请求头：
Authorization: Bearer {crp_token}  或其他方式？

请求参数：
{
    "project_name": "项目名称？还是项目ID？",
    "commit_hash": "git commit hash",
    "architectures": ["amd64", "arm64"],  // 参数名称是这个吗？
    "branch_id": "分支ID",  // 必填还是可选？
    "topic_id": "主题ID"    // 必填还是可选？
    // 还有其他参数吗？
}

响应示例：
{
    "success": true,
    "build_id": "构建任务ID",
    "url": "任务详情页面链接",
    // 其他字段？
}

错误响应示例：
```

备注：/home/uos/Dev/dev-tool/package-crp.py 参考这个文件，里面有具体的API使用实现

#### 2. 查询打包状态接口
```
接口用途：查询指定打包任务的当前状态
请求方式：POST / GET / PUT / DELETE （请标注）
接口地址：

请求头：

请求参数：
{
    "build_id": "构建任务ID"
    // 还需要其他参数吗？
}

响应示例：
{
    "success": true,
    "build_id": "xxx",
    "status": "building / success / failed / pending",  // 所有可能的状态值？
    "progress": 80,  // 有进度信息吗？
    "error": "错误信息（如果失败）",
    "logs": "构建日志链接？",
    // 其他字段？
}
```

备注：/home/uos/Dev/dev-tool/package-crp.py 参考这个文件，里面有具体的API使用实现以及打包任务列表的查询方式

#### 3. 获取CRP主题列表接口
```
接口用途：获取可用的CRP主题列表（用于下拉选择）
请求方式：
接口地址：

响应示例：
[
    {
        "id": "主题ID",
        "name": "主题名称",
        "description": "描述",
        // 其他字段？
    }
]

这个接口已经有了吗？还是需要新提供？
```

备注：在主题列表中你已经实现了这个接口

#### 4. CRP Token 获取方式
```
问题：
1. crp_token 是通过 ~/Dev/dev-tool/gen_pwd.py 脚本生成的，这个脚本的具体用法是什么？
   命令格式：python gen_pwd.py [参数]
   
2. 生成的token有效期是多久？需要定期刷新吗？

3. 脚本运行后，token存储在哪里？直接输出到stdout？还是写入文件？
```

备注：
/home/uos/Dev/dev-tool/gen-crp-pwd.py 这里获取，可以直接拷贝到项目中，具体使用方法直接参考这个项目/home/uos/Dev/dev-tool/，不看web文件夹

### 二、GitHub API

#### 1. 创建 Pull Request
```
问题：
1. 是否使用 GitHub CLI (gh) 工具？还是直接调用 REST API？

如果使用 gh 命令：
gh pr create --repo OWNER/REPO --head BRANCH --base BRANCH --title "xxx" --body "xxx"
这样对吗？需要哪些额外参数？

如果使用 REST API：
POST https://api.github.com/repos/{owner}/{repo}/pulls
Headers: Authorization: token {github_token}
Body: {
    "title": "PR标题",
    "head": "源分支",
    "base": "目标分支",
    "body": "PR描述"
}
这样对吗？
```

备注：参考/home/uos/Dev/dev-tool/git-tag.py，里面有提交PR的逻辑，包括可能还需要fork仓库，可能需要用户填写全局配置，上游组织和自己的github

#### 2. 查询 PR 状态
```
接口地址：GET /repos/{owner}/{repo}/pulls/{pr_number}

响应中需要关注哪些字段？
{
    "state": "open / closed",
    "merged": true/false,
    "merged_at": "合并时间",
    // 还有其他重要字段吗？
}
```

应该只需要合并状态吧

#### 3. GitHub Token 权限要求
```
Token 需要哪些权限（scopes）？
- repo (完整仓库访问)
- workflow (如果需要触发CI)
- 其他？

Token 从哪里获取？在GitHub设置里生成个人访问令牌？
```

这个暂定，我可以提供token，但是具体的访问方式我不知道

### 三、Gerrit API

#### 1. 查询提交列表
```
接口用途：查询某个分支的最近提交，用于检查GitHub是否同步到Gerrit
当前使用的接口：已有 gerrit_service.py 中的实现

需要确认：
1. gerrit_service.get_commits() 方法返回的commit对象包含哪些字段？
   - commit: commit hash
   - 还有其他字段吗？

2. Gerrit API 是否需要认证？使用LDAP账号密码？
```

请查询项目中的这个文件；gerrit-api.php

#### 2. 推送到 Gerrit
```
问题：
1. 推送到Gerrit是使用 git push 命令吗？
   格式：git push origin HEAD:refs/for/{branch}
   
2. 需要设置特殊的 git config 吗？比如 gitreview？

3. 推送后如何获取 Change-Id 或者 Review URL？
```

git review -R <分支名称：例：master> -r <远程名称,例：origin>

### 四、系统工具要求

#### 1. dch 工具（devscripts）
```
安装命令：
Ubuntu/Debian: sudo apt install devscripts

使用方式：
dch --newversion {version} --distribution unstable "{message}"
参数说明：
- --newversion: 新版本号
- --distribution: 发行版（unstable / stable / testing）
- message: changelog 消息

还有其他常用参数吗？比如：
- --maintainer: 维护者信息
- --urgency: 紧急程度
```

备注：/home/uos/Dev/dev-tool/package-crp.py 参考这个文件，里面有具体生成的方式

#### 2. GitHub CLI (gh)
```
安装命令：
Ubuntu/Debian: sudo apt install gh

认证方式：
gh auth login
或者：gh auth login --with-token < token_file

需要哪些子命令？
- gh pr create
- gh pr view
- gh pr status
- 其他？
```

这些我会提前配置

#### 3. Git 配置
```
需要配置哪些 git config？
- user.name
- user.email
- 代理设置（如果需要）
- Gerrit相关配置？
```

这些我会提前配置

### 五、项目配置参数

#### 1. 项目仓库结构
```
问题：
1. Debian 项目的 changelog 文件路径是固定的吗？
   通常是：debian/changelog
   还是可能在其他位置？

2. 是否所有项目都有 debian/ 目录？
   如果没有怎么处理？

3. changelog 格式是标准的 Debian changelog 格式吗？
```

都在debian/changelog，没有直接报错

#### 2. 版本号规则
```
问题：
1. 版本号格式是什么？
   例如：6.0.52 或 1:6.0.52-1 或其他格式？

2. 版本号的递增规则？
   当前版本如何解析？
   如何确定下一个版本号？

3. 版本号是否需要包含发行版后缀？比如 -deepin1？
```

备注：参考/home/uos/Dev/dev-tool/git-tag.py，里面有生成changelog的逻辑，可以参考

#### 3. 分支命名规则
```
问题：
1. 自动创建的打包分支名称格式是什么？
   当前计划：autopack/{version}
   是否需要包含日期？比如：autopack/{version}-{date}

2. 分支创建后需要设置上游吗？

3. PR 合并后是否自动删除分支？
```
这个随便你，不需要包含日期吧，应该也不需要删除分支，一切以你为主，能达到目的就行

### 六、架构参数

#### 1. 支持的架构列表
```
当前支持的架构：
- amd64
- arm64
- loongarch64
- riscv64

问题：
1. 这些架构名称在CRP平台中是否一致？还是有不同的命名？
   比如：amd64 vs x86_64

2. 是否所有项目都支持所有架构？
   如何判断项目支持哪些架构？

3. 默认应该选择哪些架构？
```

默认架构后面再说，你现在只需要读取用户打包前设置的打包架构列表

### 七、超时和重试配置

#### 1. 各步骤超时时间
```
请确认以下超时时间是否合理：

1. PR 合并超时：30分钟（1800秒）
   - 检查间隔：30秒
   - 合理吗？需要调整吗？备注：改为一分钟吧

2. GitHub → Gerrit 同步超时：10分钟（600秒）
   - 检查间隔：30秒
   - 通常需要多久才能同步？ 备注：合理

3. CRP 打包超时：1小时（3600秒）
   - 检查间隔：60秒
   - 实际打包通常需要多久？ 备注：最长两个小时吧，有时候打包高峰期

4. 网络请求超时：多少秒合适？ 备注：20秒
```

#### 2. 重试策略
```
问题：
1. 哪些错误需要自动重试？
   - 网络超时
   - API 限流（429）
   - 服务器错误（5xx）
   - 其他？

2. 重试次数和间隔？
   - 立即重试 vs 指数退避
   - 最多重试几次？

3. 哪些错误不应该重试？
   - 认证失败（401/403）
   - 参数错误（400）
   - 其他？
```

你自己看

### 八、日志和通知

#### 1. 日志级别
```
问题：
1. 日志需要记录到文件吗？还是只存数据库？
都可以，但是应该要给用户日志显示的地方，错误日志要标红

2. 需要哪些日志级别？
   - DEBUG: 详细调试信息
   - INFO: 一般信息
   - WARNING: 警告
   - ERROR: 错误
   - 如何区分？

3. 是否需要结构化日志（JSON格式）？
```
不需要，存储怎么存储你来定，但是显示一定要是用户可读的，需要在界面上显示

#### 2. 通知方式（未来扩展）
```
问题：
1. 任务完成/失败时需要通知吗？
   - 邮件
   - 企业微信/钉钉
   - 其他IM工具

2. 通知内容应该包含什么信息？
```

不需要通知用户，展示在界面上就行

### 九、其他问题

#### 1. 并发限制
```
问题：
1. 最多允许同时执行多少个打包任务？
   当前设置：3个
   是否合理？

2. 是否需要按项目限制？
   比如：同一个项目同时只能有1个任务在执行

3. 服务器资源如何？CPU/内存/磁盘够用吗？
```

可配置吧，默认3个，有一些敏感操作可能要做互斥锁，避免同时运行

#### 2. 仓库管理
```
问题：
1. 本地仓库存储路径：
   当前设置：~/.cache/deepin-autopack/repo/
   这个路径合适吗？

2. 是否使用 Git Worktree 来隔离不同的任务？
   优点：多个任务可以并行，不会互相影响
   缺点：占用更多磁盘空间

3. 仓库如何清理？
   - 定期清理旧的 worktree
   - 保留多久的历史记录
```

原则是配置好的本地仓库要保持最新的状态，不要删除

#### 3. 权限和安全
```
问题：
1. LDAP 密码如何存储？
   - 数据库加密存储
   - 环境变量
   - 配置文件

2. GitHub Token / CRP Token 如何存储？
   - 同上

3. 是否需要多用户支持？
   - 每个用户有自己的配置
   - 还是全局共享配置
```

和现有的一致就行

---

## 填写说明

请在上面对应的位置填写具体信息，可以直接修改这个文件。

填写完成后，我将根据你提供的信息来实施具体的代码。

如果有些信息暂时不确定，可以标注为 `TODO` 或 `待确认`，我们可以先用占位符实现，后续再补充。